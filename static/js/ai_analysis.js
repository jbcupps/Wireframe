/**
 * AI Analysis Module for 4D Manifold Explorer
 * Provides machine learning and data analysis capabilities for
 * topological data generated by the evolutionary algorithm.
 */

class AIAnalysisModule {
    constructor() {
        this.clusterCount = 3; // Default number of clusters for k-means
        this.dataPoints = []; // Stores topological data for analysis
        this.clusterResults = null; // Stores clustering results
        this.readyState = false; // Indicates if module is ready to analyze
        this.modelLoaded = false; // Indicates if ML model is loaded
        
        // Initialize the module
        this.initialize();
    }
    
    /**
     * Initialize the AI Analysis module
     */
    initialize() {
        console.log("Initializing AI Analysis Module");
        
        // Load TensorFlow.js if needed
        if (typeof tf === 'undefined') {
            this.loadTensorFlow();
        } else {
            this.modelLoaded = true;
            this.readyState = true;
        }
        
        // Setup event listeners for UI elements
        this.setupEventListeners();
    }
    
    /**
     * Load TensorFlow.js dynamically
     */
    loadTensorFlow() {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js';
        script.async = true;
        
        script.onload = () => {
            console.log("TensorFlow.js loaded successfully");
            this.modelLoaded = true;
            this.readyState = true;
            
            // Initialize the model once TensorFlow is loaded
            this.initializeModel();
        };
        
        script.onerror = () => {
            console.error("Failed to load TensorFlow.js");
            // Fallback to basic analysis without TensorFlow
            this.readyState = true;
        };
        
        document.head.appendChild(script);
    }
    
    /**
     * Initialize the ML model for topological data analysis
     */
    initializeModel() {
        if (!this.modelLoaded) return;
        
        try {
            // Create a simple clustering model using TensorFlow.js
            this.model = tf.sequential();
            this.model.add(tf.layers.dense({
                units: 16,
                activation: 'relu',
                inputShape: [4] // Input features: twist_x, twist_y, twist_z, twist_t
            }));
            this.model.add(tf.layers.dense({
                units: 8,
                activation: 'relu'
            }));
            this.model.add(tf.layers.dense({
                units: this.clusterCount,
                activation: 'softmax'
            }));
            
            // Compile the model
            this.model.compile({
                optimizer: tf.train.adam(),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            console.log("ML model initialized");
        } catch (error) {
            console.error("Error initializing ML model:", error);
        }
    }
    
    /**
     * Setup event listeners for UI controls
     */
    setupEventListeners() {
        // Add event listeners when the document is ready
        document.addEventListener('DOMContentLoaded', () => {
            const clusterBtn = document.getElementById('run-clustering-btn');
            if (clusterBtn) {
                clusterBtn.addEventListener('click', () => this.runClustering());
            }
            
            const analysisBtn = document.getElementById('predict-particle-btn');
            if (analysisBtn) {
                analysisBtn.addEventListener('click', () => this.predictParticleType());
            }
            
            // Cluster count slider
            const clusterSlider = document.getElementById('cluster-count');
            if (clusterSlider) {
                clusterSlider.addEventListener('change', (e) => {
                    this.clusterCount = parseInt(e.target.value);
                    document.getElementById('cluster-count-value').textContent = this.clusterCount;
                });
            }
        });
    }
    
    /**
     * Add topological data from an evolved population
     * @param {Array} population - Array of SubSKB objects
     */
    addPopulationData(population) {
        if (!population || !Array.isArray(population)) return;
        
        // Extract relevant features from each SubSKB
        population.forEach(skb => {
            // Skip if already in the dataset (check by ID)
            if (this.dataPoints.some(p => p.id === skb.id)) return;
            
            const dataPoint = {
                id: skb.id,
                twist_x: skb.twist_x,
                twist_y: skb.twist_y,
                twist_z: skb.twist_z,
                twist_t: skb.twist_t,
                euler: skb.euler_characteristic,
                orientable: skb.orientable ? 1 : 0,
                stiefel_whitney: skb.stiefel_whitney_class,
                timestamp: new Date().getTime()
            };
            
            this.dataPoints.push(dataPoint);
        });
        
        console.log(`Added ${population.length} data points. Total dataset size: ${this.dataPoints.length}`);
    }
    
    /**
     * Run k-means clustering on the collected data
     */
    runClustering() {
        if (!this.readyState || this.dataPoints.length < 5) {
            console.warn("Not enough data for clustering analysis");
            this.showAnalysisMessage("Not enough data points. Generate more Sub-SKBs first.");
            return;
        }
        
        // Show loading indicator
        this.showAnalysisMessage("Running clustering analysis...", true);
        
        setTimeout(() => {
            try {
                // Extract features for clustering
                const features = this.dataPoints.map(p => [
                    p.twist_x, p.twist_y, p.twist_z, p.twist_t
                ]);
                
                // Normalize data
                const normalizedFeatures = this.normalizeData(features);
                
                if (this.modelLoaded && typeof tf !== 'undefined') {
                    // Use TensorFlow.js for clustering if available
                    this.runTensorFlowClustering(normalizedFeatures);
                } else {
                    // Use simplified k-means implementation
                    this.runSimpleKMeansClustering(normalizedFeatures);
                }
                
                // Visualize the clusters
                this.visualizeClusters();
                
                // Show success message
                this.showAnalysisMessage(`Clustering complete. Found ${this.clusterCount} distinct topological clusters.`);
            } catch (error) {
                console.error("Error in clustering:", error);
                this.showAnalysisMessage("Error running clustering algorithm.");
            }
        }, 100); // Small delay to allow UI to update
    }
    
    /**
     * Run k-means clustering using TensorFlow.js
     * @param {Array} normalizedFeatures - Normalized feature data
     */
    runTensorFlowClustering(normalizedFeatures) {
        // Convert to tensor
        const tensorData = tf.tensor2d(normalizedFeatures);
        
        // Define the K-means function
        const runKMeans = async (tensor, numClusters, maxIterations = 20) => {
            // Randomly initialize centroids
            let centroids = tensor.slice([0, 0], [numClusters, tensor.shape[1]]);
            
            // K-means algorithm
            let assignments = tf.zeros([tensor.shape[0]], 'int32');
            
            for (let iteration = 0; iteration < maxIterations; iteration++) {
                // Compute distances from points to centroids
                const expandedTensor = tensor.expandDims(1);
                const expandedCentroids = centroids.expandDims(0);
                const distances = expandedTensor.sub(expandedCentroids).pow(2).sum(2);
                
                // Assign points to nearest centroid
                const newAssignments = distances.argMin(1);
                
                // Check if assignments changed
                const changed = tf.notEqual(newAssignments, assignments).sum().dataSync()[0];
                assignments = newAssignments;
                
                if (changed === 0 && iteration > 0) {
                    break; // Convergence reached
                }
                
                // Update centroids
                const newCentroids = [];
                for (let k = 0; k < numClusters; k++) {
                    const clusterMask = tf.equal(assignments, tf.scalar(k, 'int32'));
                    const clusterSize = clusterMask.sum().dataSync()[0];
                    
                    if (clusterSize > 0) {
                        const expandedMask = clusterMask.expandDims(1);
                        const centroid = tensor.mul(expandedMask).sum(0).div(clusterSize);
                        newCentroids.push(centroid);
                    } else {
                        // If empty cluster, keep old centroid
                        newCentroids.push(centroids.slice([k, 0], [1, centroids.shape[1]]));
                    }
                }
                centroids = tf.concat(newCentroids, 0);
            }
            
            // Return final assignments and centroids
            return {
                assignments: assignments.dataSync(),
                centroids: centroids.arraySync()
            };
        };
        
        // Run k-means and get results
        runKMeans(tensorData, this.clusterCount).then(result => {
            this.clusterResults = {
                assignments: Array.from(result.assignments),
                centroids: result.centroids
            };
            
            // Assign clusters to data points
            this.dataPoints.forEach((point, index) => {
                point.cluster = this.clusterResults.assignments[index];
            });
            
            // Update the visualization
            this.visualizeClusters();
        });
    }
    
    /**
     * Run a simplified k-means clustering algorithm
     * (Fallback when TensorFlow.js is not available)
     * @param {Array} normalizedFeatures - Normalized feature data
     */
    runSimpleKMeansClustering(normalizedFeatures) {
        const data = normalizedFeatures;
        const k = this.clusterCount;
        const maxIterations = 20;
        
        // Randomly select initial centroids
        const centroids = [];
        const usedIndices = new Set();
        
        for (let i = 0; i < k; i++) {
            let randomIndex;
            do {
                randomIndex = Math.floor(Math.random() * data.length);
            } while (usedIndices.has(randomIndex) && usedIndices.size < data.length);
            
            usedIndices.add(randomIndex);
            centroids.push([...data[randomIndex]]);
        }
        
        // Array to store cluster assignments
        let assignments = new Array(data.length).fill(0);
        
        // K-means iterations
        for (let iteration = 0; iteration < maxIterations; iteration++) {
            // Assign points to nearest centroid
            const newAssignments = [];
            
            for (let i = 0; i < data.length; i++) {
                let minDistance = Infinity;
                let closestCentroid = 0;
                
                for (let j = 0; j < centroids.length; j++) {
                    const distance = this.euclideanDistance(data[i], centroids[j]);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCentroid = j;
                    }
                }
                
                newAssignments.push(closestCentroid);
            }
            
            // Check for convergence
            let changed = false;
            for (let i = 0; i < assignments.length; i++) {
                if (assignments[i] !== newAssignments[i]) {
                    changed = true;
                    break;
                }
            }
            
            assignments = newAssignments;
            
            if (!changed && iteration > 0) {
                break; // Convergence reached
            }
            
            // Update centroids
            const newCentroids = Array(k).fill().map(() => Array(data[0].length).fill(0));
            const counts = Array(k).fill(0);
            
            for (let i = 0; i < data.length; i++) {
                const cluster = assignments[i];
                counts[cluster]++;
                
                for (let j = 0; j < data[i].length; j++) {
                    newCentroids[cluster][j] += data[i][j];
                }
            }
            
            for (let i = 0; i < k; i++) {
                if (counts[i] > 0) {
                    for (let j = 0; j < newCentroids[i].length; j++) {
                        newCentroids[i][j] /= counts[i];
                    }
                } else {
                    // If empty cluster, keep old centroid
                    newCentroids[i] = [...centroids[i]];
                }
            }
            
            centroids.length = 0;
            centroids.push(...newCentroids);
        }
        
        this.clusterResults = {
            assignments: assignments,
            centroids: centroids
        };
        
        // Assign clusters to data points
        this.dataPoints.forEach((point, index) => {
            point.cluster = this.clusterResults.assignments[index];
        });
    }
    
    /**
     * Calculate Euclidean distance between two points
     * @param {Array} point1 - First point coordinates
     * @param {Array} point2 - Second point coordinates
     * @returns {number} - Euclidean distance
     */
    euclideanDistance(point1, point2) {
        return Math.sqrt(
            point1.reduce((sum, value, index) => {
                return sum + Math.pow(value - point2[index], 2);
            }, 0)
        );
    }
    
    /**
     * Normalize data to [0,1] range
     * @param {Array} features - Array of feature vectors
     * @returns {Array} - Normalized features
     */
    normalizeData(features) {
        // Find min and max for each feature
        const dimensions = features[0].length;
        const mins = Array(dimensions).fill(Infinity);
        const maxs = Array(dimensions).fill(-Infinity);
        
        features.forEach(point => {
            for (let i = 0; i < dimensions; i++) {
                mins[i] = Math.min(mins[i], point[i]);
                maxs[i] = Math.max(maxs[i], point[i]);
            }
        });
        
        // Normalize each point
        return features.map(point => {
            return point.map((value, index) => {
                const range = maxs[index] - mins[index];
                return range > 0 ? (value - mins[index]) / range : 0;
            });
        });
    }
    
    /**
     * Visualize clustering results
     */
    visualizeClusters() {
        if (!this.clusterResults) return;
        
        const clusterContainer = document.getElementById('cluster-visualization');
        if (!clusterContainer) return;
        
        // Prepare data for plotting
        const clusterData = [];
        
        // Define colors for clusters
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', 
            '#FF9F40', '#8AC54B', '#F94144', '#577590', '#43AA8B'
        ];
        
        // Create a trace for each cluster
        for (let i = 0; i < this.clusterCount; i++) {
            const clusterPoints = this.dataPoints.filter(p => p.cluster === i);
            
            if (clusterPoints.length > 0) {
                const trace = {
                    x: clusterPoints.map(p => p.twist_x),
                    y: clusterPoints.map(p => p.twist_y),
                    mode: 'markers',
                    type: 'scatter',
                    name: `Cluster ${i+1}`,
                    marker: {
                        color: colors[i % colors.length],
                        size: 10
                    },
                    text: clusterPoints.map(p => 
                        `ID: ${p.id}<br>` +
                        `Twist X: ${p.twist_x.toFixed(2)}<br>` +
                        `Twist Y: ${p.twist_y.toFixed(2)}<br>` +
                        `Twist Z: ${p.twist_z.toFixed(2)}<br>` +
                        `Twist T: ${p.twist_t.toFixed(2)}<br>` +
                        `Orientable: ${p.orientable ? 'Yes' : 'No'}`
                    ),
                    hoverinfo: 'text'
                };
                
                clusterData.push(trace);
            }
        }
        
        // Add centroid points if available
        if (this.clusterResults.centroids) {
            const centroidTrace = {
                x: this.clusterResults.centroids.map(c => 
                    this.denormalizeValue(c[0], 'twist_x')),
                y: this.clusterResults.centroids.map(c => 
                    this.denormalizeValue(c[1], 'twist_y')),
                mode: 'markers',
                type: 'scatter',
                name: 'Centroids',
                marker: {
                    color: 'black',
                    size: 12,
                    symbol: 'x'
                }
            };
            
            clusterData.push(centroidTrace);
        }
        
        // Plot layout
        const layout = {
            title: 'Topological Clustering Results',
            xaxis: {
                title: 'Twist X (Electric Charge)'
            },
            yaxis: {
                title: 'Twist Y (Weak Isospin)'
            },
            hovermode: 'closest',
            legend: {
                x: 1,
                y: 0.5
            },
            margin: {
                l: 50,
                r: 50,
                t: 50,
                b: 50
            }
        };
        
        // Create the plot
        Plotly.newPlot(clusterContainer, clusterData, layout);
        
        // Also update the cluster statistics table
        this.updateClusterStatistics();
    }
    
    /**
     * Denormalize a value back to original scale
     * @param {number} normalizedValue - Value in [0,1] range
     * @param {string} featureName - Name of the feature
     * @returns {number} - Denormalized value
     */
    denormalizeValue(normalizedValue, featureName) {
        // Find min and max for the feature
        let min = Infinity;
        let max = -Infinity;
        
        this.dataPoints.forEach(point => {
            min = Math.min(min, point[featureName]);
            max = Math.max(max, point[featureName]);
        });
        
        return normalizedValue * (max - min) + min;
    }
    
    /**
     * Update cluster statistics table
     */
    updateClusterStatistics() {
        const statsContainer = document.getElementById('cluster-statistics');
        if (!statsContainer) return;
        
        let html = `
            <h4>Cluster Statistics</h4>
            <table class="table table-sm">
                <thead>
                    <tr>
                        <th>Cluster</th>
                        <th>Size</th>
                        <th>Avg. Twist X</th>
                        <th>Avg. Twist Y</th>
                        <th>Avg. Twist Z</th>
                        <th>Avg. Twist T</th>
                        <th>% Orientable</th>
                        <th>Particle Type</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        // Calculate statistics for each cluster
        for (let i = 0; i < this.clusterCount; i++) {
            const clusterPoints = this.dataPoints.filter(p => p.cluster === i);
            
            if (clusterPoints.length > 0) {
                // Calculate averages
                const avgTwistX = clusterPoints.reduce((sum, p) => sum + p.twist_x, 0) / clusterPoints.length;
                const avgTwistY = clusterPoints.reduce((sum, p) => sum + p.twist_y, 0) / clusterPoints.length;
                const avgTwistZ = clusterPoints.reduce((sum, p) => sum + p.twist_z, 0) / clusterPoints.length;
                const avgTwistT = clusterPoints.reduce((sum, p) => sum + p.twist_t, 0) / clusterPoints.length;
                const pctOrientable = clusterPoints.filter(p => p.orientable).length / clusterPoints.length * 100;
                
                // Guess particle type based on twist values
                const particleType = this.guessParticleType(avgTwistX, avgTwistY, avgTwistZ);
                
                html += `
                    <tr>
                        <td>Cluster ${i+1}</td>
                        <td>${clusterPoints.length}</td>
                        <td>${avgTwistX.toFixed(2)}</td>
                        <td>${avgTwistY.toFixed(2)}</td>
                        <td>${avgTwistZ.toFixed(2)}</td>
                        <td>${avgTwistT.toFixed(2)}</td>
                        <td>${pctOrientable.toFixed(1)}%</td>
                        <td>${particleType}</td>
                    </tr>
                `;
            }
        }
        
        html += `
                </tbody>
            </table>
        `;
        
        statsContainer.innerHTML = html;
    }
    
    /**
     * Guess particle type based on twist values
     * @param {number} twistX - X twist value (electric charge)
     * @param {number} twistY - Y twist value (weak isospin)
     * @param {number} twistZ - Z twist value (color charge)
     * @returns {string} - Guessed particle type
     */
    guessParticleType(twistX, twistY, twistZ) {
        // Simple heuristic based on the physics interpretation of twist values
        
        // Electric charge (twist X)
        const charge = twistX;
        
        // Check for common particle patterns
        if (Math.abs(charge - 2/3) < 0.2) {
            return "Up-like Quark";
        } else if (Math.abs(charge + 1/3) < 0.2) {
            return "Down-like Quark";
        } else if (Math.abs(charge - 0) < 0.2) {
            return "Neutral Particle";
        } else if (Math.abs(charge - 1) < 0.2) {
            return "Positively Charged Lepton";
        } else if (Math.abs(charge + 1) < 0.2) {
            return "Negatively Charged Lepton";
        } else {
            return "Unknown";
        }
    }
    
    /**
     * Predict particle type for a specific SKB configuration
     */
    predictParticleType() {
        const selectedSKB = window.evolutionUI?.selectedIndividual;
        
        if (!selectedSKB) {
            this.showAnalysisMessage("Please select a Sub-SKB configuration first.");
            return;
        }
        
        // Show loading indicator
        this.showAnalysisMessage("Analyzing configuration...", true);
        
        setTimeout(() => {
            // Extract features
            const features = [
                selectedSKB.twist_x,
                selectedSKB.twist_y,
                selectedSKB.twist_z,
                selectedSKB.twist_t
            ];
            
            // Normalize features
            const allFeatures = this.dataPoints.map(p => [
                p.twist_x, p.twist_y, p.twist_z, p.twist_t
            ]);
            allFeatures.push(features);
            const normalizedFeatures = this.normalizeData(allFeatures);
            const normalizedInput = normalizedFeatures[normalizedFeatures.length - 1];
            
            // Make prediction
            let prediction;
            
            if (this.modelLoaded && typeof tf !== 'undefined') {
                // Use TensorFlow model if available
                const inputTensor = tf.tensor2d([normalizedInput]);
                const predictions = this.model.predict(inputTensor);
                const probabilities = predictions.dataSync();
                
                // Find highest probability class
                let maxProb = 0;
                let maxClass = 0;
                
                for (let i = 0; i < probabilities.length; i++) {
                    if (probabilities[i] > maxProb) {
                        maxProb = probabilities[i];
                        maxClass = i;
                    }
                }
                
                // Map class to particle type
                prediction = this.guessParticleType(
                    selectedSKB.twist_x,
                    selectedSKB.twist_y,
                    selectedSKB.twist_z
                );
                
                // Clean up tensors
                inputTensor.dispose();
                predictions.dispose();
            } else {
                // Fallback to simple heuristic
                prediction = this.guessParticleType(
                    selectedSKB.twist_x,
                    selectedSKB.twist_y,
                    selectedSKB.twist_z
                );
            }
            
            // Display results
            this.showAnalysisMessage("Analysis complete.");
            this.displayParticlePrediction(selectedSKB, prediction);
        }, 100);
    }
    
    /**
     * Display particle prediction results
     * @param {Object} skb - The SKB configuration
     * @param {string} particleType - Predicted particle type
     */
    displayParticlePrediction(skb, particleType) {
        const resultDiv = document.getElementById('prediction-results');
        if (!resultDiv) return;
        
        // Calculate standard model mapping
        const charge = skb.twist_x;
        const isospin = skb.twist_y;
        const colorCharge = skb.twist_z;
        
        // Classification confidence based on how close the values are to standard particles
        let confidence = 0;
        let matchedParticle = "";
        
        // Check against known particles
        if (Math.abs(charge - 2/3) < 0.2 && particleType === "Up-like Quark") {
            confidence = 1 - Math.abs(charge - 2/3);
            matchedParticle = "up quark";
        } else if (Math.abs(charge + 1/3) < 0.2 && particleType === "Down-like Quark") {
            confidence = 1 - Math.abs(charge + 1/3);
            matchedParticle = "down quark";
        } else if (Math.abs(charge + 1) < 0.2 && particleType === "Negatively Charged Lepton") {
            confidence = 1 - Math.abs(charge + 1);
            matchedParticle = "electron";
        } else if (Math.abs(charge - 0) < 0.2 && particleType === "Neutral Particle") {
            confidence = 1 - Math.abs(charge);
            matchedParticle = "neutrino";
        }
        
        confidence = Math.max(0, Math.min(1, confidence));
        
        // Create the result HTML
        let html = `
            <div class="card">
                <div class="card-header">
                    <h5>Particle Analysis Results</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6">
                            <h6>SKB Configuration:</h6>
                            <ul>
                                <li>Twist X (Electric Charge): ${skb.twist_x.toFixed(2)}</li>
                                <li>Twist Y (Weak Isospin): ${skb.twist_y.toFixed(2)}</li>
                                <li>Twist Z (Color Charge): ${skb.twist_z.toFixed(2)}</li>
                                <li>Twist T (Mass): ${skb.twist_t.toFixed(2)}</li>
                                <li>Orientable: ${skb.orientable ? 'Yes' : 'No'}</li>
                                <li>Euler Characteristic: ${skb.euler_characteristic}</li>
                            </ul>
                        </div>
                        <div class="col-md-6">
                            <h6>Standard Model Mapping:</h6>
                            <ul>
                                <li>Predicted Type: <strong>${particleType}</strong></li>
                                <li>Closest Match: <strong>${matchedParticle}</strong></li>
                                <li>Confidence: ${(confidence * 100).toFixed(1)}%</li>
                                <li>Electric Charge: ${charge.toFixed(2)} e</li>
                                <li>Weak Isospin: ${isospin.toFixed(2)}</li>
                                <li>Color Charge: ${colorCharge > 0 ? 'Yes' : 'No'}</li>
                            </ul>
                        </div>
                    </div>
                    <div class="mt-3">
                        <h6>Topological Properties:</h6>
                        <p>The topological properties of this configuration suggest it behaves as a ${particleType.toLowerCase()}. 
                        The ${matchedParticle ? 'match to a ' + matchedParticle : 'particle classification'} is based on its twist parameters,
                        which correspond to quantum numbers in the Standard Model.</p>
                    </div>
                </div>
            </div>
        `;
        
        resultDiv.innerHTML = html;
    }
    
    /**
     * Show a message in the analysis status area
     * @param {string} message - Message to display
     * @param {boolean} isLoading - Whether to show loading spinner
     */
    showAnalysisMessage(message, isLoading = false) {
        const statusDiv = document.getElementById('analysis-status');
        if (!statusDiv) return;
        
        if (isLoading) {
            statusDiv.innerHTML = `<div class="alert alert-info">
                <i class="fas fa-spinner fa-spin mr-2"></i> ${message}
            </div>`;
        } else {
            statusDiv.innerHTML = `<div class="alert alert-info">
                <i class="fas fa-info-circle mr-2"></i> ${message}
            </div>`;
        }
    }
}

// Initialize the AI Analysis module when the page loads
document.addEventListener('DOMContentLoaded', () => {
    // Create global instance if on the evolution page
    if (document.getElementById('evolution-container')) {
        window.aiAnalysis = new AIAnalysisModule();
        
        // Add connection to evolutionary algorithm
        if (window.evolutionUI) {
            // Add AI Analysis button to the evolution UI
            const buttonContainer = document.querySelector('.evolution-controls');
            if (buttonContainer) {
                const analyzeButton = document.createElement('button');
                analyzeButton.id = 'analyze-population-btn';
                analyzeButton.className = 'btn btn-info ml-2';
                analyzeButton.innerHTML = '<i class="fas fa-brain"></i> Analyze Population';
                analyzeButton.addEventListener('click', () => {
                    if (window.aiAnalysis && window.evolutionUI.algorithm) {
                        window.aiAnalysis.addPopulationData(window.evolutionUI.algorithm.population);
                        window.aiAnalysis.runClustering();
                    }
                });
                
                buttonContainer.appendChild(analyzeButton);
            }
        }
    }
}); 